{"version":3,"sources":["sw.js"],"names":["importScripts","static","addEventListener","evt","console","log","$C$","caches","open","addAll","waitUntil","self","clients","claim","req","request","clone","url","URL","origin","method","pathname","match","length","href","respondWith","graphql","location","$$thenNet","netThen$$","$R","fetch","$R$","res","put","err"],"mappings":"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","file":"sw.js","sourceRoot":"..","sourcesContent":["importScripts(\r\n  'https://unpkg.com/ramda@0.26.1/dist/ramda.min.js',\r\n  'https://unpkg.com/axios@0.19.0/dist/axios.min.js',\r\n  'https://unpkg.com/swivel@4.0.3/dist/swivel.min.js'\r\n)\r\n\r\nlet static = ['index.html', 'index.js']\r\n\r\naddEventListener('install', async evt => {\r\n  console.log('Service Worker installing.')\r\n  const $C$ = await caches.open('$install$') // create a new cache object\r\n  $C$.addAll(static) // put local static assets in\r\n})\r\n\r\n// addEventListener('activate', evt => console.log('Service Worker activating.'))\r\n\r\n// Immediately claim any new clients. This is not needed to send messages, but\r\n// makes for a better demo experience since the user does not need to refresh.\r\n// A more complete example of this given in the immediate-claim recipe.\r\naddEventListener('activate', evt => {\r\n  console.log('Service Worker activating.')\r\n  evt.waitUntil(self.clients.claim())\r\n})\r\n\r\naddEventListener('message', evt =>\r\n  console.log('Service Worker message recieved!:', evt)\r\n)\r\n\r\n// swivel.on('data', function handler(context, ...data) {\r\n//   console.log('swivel received data in sw.js:', data)\r\n// })\r\n\r\naddEventListener('fetch', evt => {\r\n  const req = evt.request.clone()\r\n  const url = new URL(req.url) // create a url object\r\n  console.log('url.origin:', url.origin)\r\n  if (\r\n    req.method === 'POST' && // is a POST request\r\n    url.pathname.match(/graphql/g).length > 0 && // is a graphql request\r\n    url.href.match(/mutation/g) === null // isn't a mutation\r\n  ) {\r\n    evt.respondWith(graphql(req))\r\n  } else if (url.origin === location.origin) {\r\n    evt.respondWith($$thenNet(req)) // prefer cache first if own resource\r\n  } else {\r\n    evt.respondWith(netThen$$(req)) // prefer network first for external\r\n  }\r\n})\r\n\r\nconst $$thenNet = async req => {\r\n  // console.log('$$thenNet req =>', req)\r\n  const $R = await caches.match(req) // match any previous requests\r\n  return $R || fetch(req) // return matches if there, else fetch\r\n}\r\n\r\nconst netThen$$ = async req => {\r\n  const $R$ = await caches.open('$fetch$') // create a new cache object\r\n  try {\r\n    const res = await fetch(req)\r\n    $R$.put(req, res.clone()) // put a new k:v pair into the object\r\n    return res\r\n  } catch (err) {\r\n    console.log(`${err} 'GET' from network, trying caches...`) // TypeError: Failed to fetch\r\n    return await caches.match(req) // return any matches\r\n  }\r\n}\r\nconst graphql = async req => {\r\n  const url = new URL(req.url)\r\n  const $R$ = await caches.open('$graphql$') // create a new cache object\r\n  try {\r\n    const res = await fetch(req)\r\n    $R$.put(url.href, res.clone()) // put a new k:v pair into the object\r\n    return res\r\n  } catch (err) {\r\n    console.log(`${err} graphql 'POST' query from network, trying caches...`) // TypeError: Failed to fetch\r\n    return await caches.match(url.href) // return any matches\r\n  }\r\n}\r\n// other approach using IDB: https://a.kabachnik.info/offline-post-requests-via-service-worker-and-indexeddb.html\r\n"]}